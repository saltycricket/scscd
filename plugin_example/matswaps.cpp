#include "scscd.h"

namespace detail
{
    // Fetch ExtraInstanceData regardless of whether GetByType is templated or enum-based
    inline RE::ExtraInstanceData* GetXInst(RE::ExtraDataList* x)
    {
        logger::trace("> GetXInst");
        if (!x) {
            logger::trace("< is null");
            return nullptr;
        }
        auto *ptr = x->GetByType<RE::ExtraInstanceData>();
        if (!ptr) {
            logger::trace("< GetXInst GetByType returned null");
        }
        else logger::trace("< GetXInst");
        return ptr;
    }
}

// --- Revised implementations (non-template HasType and flexible worn detection) ---
static RE::ExtraDataList* GetWornXInst(RE::Actor* actor, RE::TESObjectARMO* armor)
{
    logger::trace("> GetWornXInst");
    if (!actor || !armor) {
        logger::trace("< GetWornXInst armor or actor is null");
        return nullptr;
    }

    auto inv = actor->inventoryList;
    if (!inv) {
        logger::trace("< GetWornXInst inventoryList is null");
        return nullptr;
    }

    RE::ExtraDataList* found = nullptr;

    inv->ForEachStack(
        [&](RE::BGSInventoryItem& item) {
            return item.object == armor; // restrict to this base form
        },
        [&](RE::BGSInventoryItem& item, RE::BGSInventoryItem::Stack& stack) {
            if (!stack.IsEquipped())
                return true; // keep scanning stacks

            found = stack.extra.get();
            //if (auto* xInst = detail::GetXInst(x)) {
            //    found = xInst->data.get();
            //    return false; // stop
            //}
            //else {
            //    x->AddExtra
            //    /*RE::TBO_InstanceData* idata = x->CreateInstanceData(item.object, false);
            //    if (!idata) {
            //        logger::warn("could not get instance data and could not create it, so mat swap is impossible");
            //    }*/
            //    found = idata;
            //    return false;

            //    /*if (auto* xInst = detail::GetXInst(x)) {
            //        found = xInst;
            //        return false;
            //    }
            //    else {
            //        logger::warn("could not get or create instance data, so mat swap is impossible");
            //    }*/
            //}
            return false;
        }
    );

    logger::trace(std::format("< GetWornXInst found={}", !!found));
    return found;
}

RE::ExtraDataList* GetExtraListForArmor(RE::Actor* actor, RE::TESObjectARMO* armor, bool wornOnly = false)
{
    logger::trace("> GetExtraListForArmor");
    if (!actor || !armor) {
        logger::trace("< GetExtraListForArmor armor or actor is null");
        return nullptr;
    }

    auto inv = actor->inventoryList;
    if (!inv) {
        logger::trace("< GetExtraListForArmor inventoryList is null");
        return nullptr;
    }

    RE::ExtraDataList* found = nullptr;

    inv->ForEachStack(
        [&](RE::BGSInventoryItem& item) {
            return item.object == armor;
        },
        [&](RE::BGSInventoryItem& /*item*/, RE::BGSInventoryItem::Stack& stack) {
            if (wornOnly && !stack.IsEquipped())
                return true; // skip non-worn stacks when requested

            found = stack.extra.get();
            return found == nullptr; // continue if null, stop if non-null
        }
    );

    logger::trace(std::format("< GetExtraListForArmor found={}", !!found));
    return found;
}

// if we get here we have confirmed that the armor is equipped on the actor. Note that if the
// armor was not actually equipped, then instance data won't have been generated by the engine,
// and since we are unable to generate it ourselves, this would be A Problem. So the caller
// of doMatSwaps MUST ensure the armor was equipped before calling.
void applyMatSwap(RE::Actor* actor, RE::TESObjectARMO* armor, RE::BGSMaterialSwap *swap) {
    logger::trace("> doMatSwaps");
    // After you call EquipObject(..., applyNow=true) and want to set the per-instance matswap:
    //if (auto* inst = GetWornXInst(actor, armor)) {

    actor->inventoryList->ForEachStack(
        [&](RE::BGSInventoryItem& item) {
            return item.object == armor; // restrict to this base form
        },
        [&](RE::BGSInventoryItem& item, RE::BGSInventoryItem::Stack& stack) {
            if (!stack.IsEquipped())
                return true; // keep scanning stacks
            if (item.object == armor) {
                //item.GetInstanceData() => TBO_InstanceData
                logger::trace("found a matching armor stack");
                RE::ExtraMaterialSwap* xtra = new RE::ExtraMaterialSwap(); // FIXME we're leaking
                xtra->swap = swap;
                if (auto* inst = stack.extra.get()) {
                    inst->AddExtra(xtra);
                    logger::trace(std::format("added matswap {:#010x} ({}) to armor {:#010x}; do we have it? => {}", swap->GetFormID(), swap->GetFormEditorID(), armor->GetFormID(), inst->HasType(RE::EXTRA_DATA_TYPE::kMaterialSwap)));

                    // we don't explicitly provide the TBO_InstanceData because to date there's been no way
                    // to get it. Functions all seem to return null.
                    RE::BGSObjectInstanceT<RE::TESObjectARMO> obj(armor, /*TBO_InstanceData**/nullptr);
                    //RE::ActorEquipManager::GetSingleton()->UnequipObject(actor, nullptr, 1, nullptr, 0, false, true, false, true, nullptr);
                    RE::ActorEquipManager::GetSingleton()->EquipObject(
                        actor, obj, /*stackID*/0, /*number*/1, /*slot*/nullptr,
                        /*queue*/false, /*force*/false, /*sounds*/false, /*applyNow*/true, /*locked*/true);
                    logger::trace("  : instance re-equipped");
                }
                else {
                    logger::trace(std::format("no instance data for stack of #{:#010x}", armor->GetFormID()));
                }
            }
            return true; // scan all
        });
    actor->Reset3D(true, 0xFFF, false, 0);
    
    //logger::trace("  : have TBO instance");
        //inst->CreateMaterialSwapArray();
        //logger::trace("  : created matswap array");
        //if (auto* arr = inst->GetMaterialSwapArray()) {
        //    logger::trace("  : matswap array confirmed");
        //    arr->clear();                                         // or keep/add if you allow multiples
        //    arr->push_back(swap);
        //    logger::trace("  : matswap appended");

        //    // Optional immediate visual refresh using the same instance
        //    RE::BGSObjectInstanceT<RE::TESObjectARMO> obj(armor, inst);
        //    RE::ActorEquipManager::GetSingleton()->EquipObject(
        //        actor, obj, /*stackID*/0, /*number*/1, /*slot*/nullptr,
        //        /*queue*/false, /*force*/false, /*sounds*/false, /*applyNow*/true, /*locked*/true);
        //    logger::trace("  : instance re-equipped");
        //}
        //else {
        //    logger::trace("  : matswap array was not created!");
        //}
    //}
    logger::trace("< doMatSwaps");
}
